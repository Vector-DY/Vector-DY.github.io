<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DFS剪枝与优化</title>
    <url>/2023/01/02/DFS%E5%89%AA%E6%9E%9D%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无论在深搜还是宽搜当中，我们都需要对所有的情况进行暴力枚举，要降低我们在深度优先搜索时的时间开销，剪枝优化至关重要。在具体的题目中，我们可以考虑的剪枝方法主要有以下五个方向：<br>1.优化搜索顺序：不同的搜索顺序会产生不同的搜索树规模，在大部分情况下，应当优先搜索分支较少的节点。<br>2.排除等效冗余：有些结果是数据的组合而无需考虑组内顺序，这时我们需要控制不去搜索重复状态，排除冗余。<br>3.可行性剪枝：在搜索的过程当中对当前的状态随时进行检查，发现当前分支已无法到达递归边界或已无法满足结果要求可直接回溯。<br>4.最优性剪枝：当我们发现当前分支无论数和都比最优解要差时，可提前退出。<br>5.记忆化搜索：我们可以记录每一个状态的搜索结果，当重复遍历时可以直接返回。<span id="more"></span>  </p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p><strong>ACwing 165</strong><br>链接：<a href="https://www.acwing.com/problem/content/167/">https://www.acwing.com/problem/content/167/</a><br>翰翰和达达饲养了 N 只小猫，这天，小猫们要去爬山。<br>经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕&gt;_&lt;）。<br>翰翰和达达只好花钱让它们坐索道下山。<br>索道上的缆车最大承重量为 W，而 N 只小猫的重量分别是 C1、C2……CN。<br>当然，每辆缆车上的小猫的重量之和不能超过 W。<br>每租用一辆缆车，翰翰和达达就要付 1 美元，所以他们想知道，最少需要付多少美元才能把这 N 只小猫都运送下山。<br><strong>输入格式</strong><br>第 1 行：包含两个用空格隔开的整数，N 和 W。<br>第 2..N+1 行：每行一个整数，其中第 i+1 行的整数表示第 i 只小猫的重量 Ci。<br><strong>输出格式</strong><br>输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。<br><strong>数据范围</strong><br>1≤N≤18,<br>1≤Ci≤W≤108  </p>
<p>可通过该问题体会一下几种剪枝的方法。<br>在DFS问题中我们首先考虑搜索顺序再思考其他的剪枝方法，要使未来的搜索分支较少，我们应当优先枚举较大的重量，其次对每辆缆车所需重量之和进行可行性剪枝，同时我们注意到本题要求最优解，所以可以记录当前的最优结果，当搜索分支已经超过最优解时直接跳出,在考虑好剪枝方法后，我们只需打板并注意回溯即可，非常简单。  </p>
<p><strong>完整代码如下</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> ans = N;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//最优性剪枝</span></span><br><span class="line">    <span class="keyword">if</span>(k &gt;= ans)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">        ans = k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] + w[u] &lt;= m)&#123; <span class="comment">//可行性剪枝</span></span><br><span class="line">            s[i] += w[u];</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>,k);</span><br><span class="line">            s[i] -= w[u]; <span class="comment">//恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s[k] = w[u];</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>,k + <span class="number">1</span>);</span><br><span class="line">    s[k] = <span class="number">0</span>; <span class="comment">//恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)cin&gt;&gt;w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//优化搜索顺序</span></span><br><span class="line">    <span class="built_in">sort</span>(w,w + n,cmp);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数独问题"><a href="#数独问题" class="headerlink" title="数独问题"></a>数独问题</h2><p>比较经典的DFS例题<br>数独是一种传统益智游戏，你需要把一个 9×9 的数独补充完整，使得数独中每行、每列、每个 3×3 的九宫格内数字 1∼9 均恰好出现一次。<br>请编写一个程序填写数独。<br><strong>输入格式</strong><br>输入包含多组测试用例。<br>每个测试用例占一行，包含 81 个字符，代表数独的 81 个格内数据（顺序总体由上到下，同行由左到右）。<br>每个字符都是一个数字（1−9）或一个 .（表示尚未填充）。<br>您可以假设输入中的每个谜题都只有一个解决方案。<br>文件结尾处为包含单词 end 的单行，表示输入结束。<br><strong>输出格式</strong><br>每个测试用例，输出一行数据，代表填充完全后的数独。  </p>
<p>相应链接：<br><a href="http://poj.org/problem?id=3074">http://poj.org/problem?id=3074</a><br><a href="https://www.acwing.com/problem/content/168/">https://www.acwing.com/problem/content/168/</a><br><a href="https://leetcode.cn/problems/sudoku-solver/">https://leetcode.cn/problems/sudoku-solver/</a>   </p>
<p>这道题目中没有太多的剪枝方法，但是可以用位运算进行优化，主要考虑搜索顺序、可行性及位运算优化。对于每一行列及九宫格中，可用一个9位二进制数来记录当前行、列、九宫格的状态，某一位为1时代表该位已被填上数字，在判断某位置是否可以填数时，我们将行、列及九宫格的状态求与，即可判断可否填数。<br>求二进制表示中的1可用lowbit函数来求解，代表当前数二进制表示中最低位的值。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">define</span> lowbit(<span class="keyword">x</span>) (<span class="keyword">x</span> &amp; -<span class="keyword">x</span>)</span><br></pre></td></tr></table></figure>
<p>也可直接使用__builtin_popcount()函数来实现，__builtin_popcount属于GCC提供的指令，也是通过打表实现，时间复杂度O(1)。<br>手动打表则定义ones[],map[]数组分别表示0-2^9中各个状态有多少个1、当前数为2的多少次方。<br>为优化搜索顺序，我们从空格数最少的状态开始搜索。<br>另外注意当前代码目前会卡常数TLE，需要开O2优化。</p>
<p><strong>完整代码如下</strong>  </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">9</span>,M = <span class="number">1</span> &lt;&lt; N; </span><br><span class="line"><span class="type">int</span> ones[M],map[M]; <span class="comment">//map表示的是2的次方 map[logn]=i,ones表示0-2^9中的数中每个状态有多少个1</span></span><br><span class="line"><span class="type">int</span> row[N],col[N],cell[<span class="number">3</span>][<span class="number">3</span>]; <span class="comment">//各行列九宫格状态</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">// 返回末尾的1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x / <span class="number">3</span>][y / <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  <span class="comment">//初始状态 行列9宫格没有填</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">        row[i] = col[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>; <span class="comment">//2^9 - 1种状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)&#123;</span><br><span class="line">            cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> t,<span class="type">bool</span> is_set)</span></span>&#123;   <span class="comment">//辅助函数 填数或删数 通过is_set进行判断</span></span><br><span class="line">    <span class="keyword">if</span>(is_set)s[x * N + y] = <span class="string">&#x27;1&#x27;</span> + t;</span><br><span class="line">    <span class="keyword">else</span> s[x * N + y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">    <span class="keyword">if</span>(!is_set)v = -v;</span><br><span class="line">    </span><br><span class="line">    row[x] -= v;</span><br><span class="line">    col[y] -= v;</span><br><span class="line">    cell[x / <span class="number">3</span>][y / <span class="number">3</span>] -= v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cnt)<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//填满所有空格时结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> minv = <span class="number">10</span>;  <span class="comment">//最多可以填10个数</span></span><br><span class="line">    <span class="type">int</span> x,y; <span class="comment">//循环完后x y存储的就是分支数量最少的格子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i * N + j] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> state = <span class="built_in">get</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(ones[state] &lt; minv)&#123;</span><br><span class="line">                    minv = ones[state];</span><br><span class="line">                    x = i,y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> state = <span class="built_in">get</span>(x,y);  <span class="comment">//从当前位置开始搜索</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = state; i ;i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        <span class="type">int</span> t = map[<span class="built_in">lowbit</span>(i)];   <span class="comment">//从表中取数</span></span><br><span class="line">        <span class="built_in">draw</span>(x,y,t,<span class="literal">true</span>);           </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(cnt - <span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">draw</span>(x,y,t,<span class="literal">false</span>);        <span class="comment">//回溯后恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)map[<span class="number">1</span> &lt;&lt; i] = i; <span class="comment">//打表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1</span> &lt;&lt; N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">            ones[i] += i &gt;&gt; j &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s,s[<span class="number">0</span>] != <span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//空格的数目  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,k = <span class="number">0</span>;i &lt; N;i++)&#123;   <span class="comment">//输入数独并统计空格数目</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; N;j++,k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[k] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> t = s[k] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="built_in">draw</span>(i,j,t,<span class="literal">true</span>);     </span><br><span class="line">                &#125;<span class="keyword">else</span> cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(cnt);</span><br><span class="line">        <span class="built_in">puts</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展练习"><a href="#扩展练习" class="headerlink" title="扩展练习"></a>扩展练习</h2><p><strong>sticks</strong><br>乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过 50 个长度单位。<br>然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。<br>请你设计一个程序，帮助乔治计算木棒的可能最小长度。<br>每一节木棍的长度都用大于零的整数表示。<br><strong>输入格式</strong><br>输入包含多组数据，每组数据包括两行。<br>第一行是一个不超过 64 的整数，表示砍断之后共有多少节木棍。<br>第二行是截断以后，所得到的各节木棍的长度。<br>在最后一组数据之后，是一个零。<br><strong>输出格式</strong><br>为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。<br><strong>数据范围</strong><br>数据保证每一节木棍的长度均不大于 50。<br>本题链接：<a href="https://vjudge.net/problem/UVA-307">https://vjudge.net/problem/UVA-307</a><br>首先考虑搜索顺序，为使未来分支较少，我们优先枚举长度较大的木棍。<br>其次，枚举木棒的长度时，长度length要被所有木棍的总长度sum整除才能符合题意。<br>比较细节的是等效冗余的考虑，主要有以下四个方面：<br>1.组内顺序不影响结果，可以不用重复搜索<br>2.在枚举木棍的过程中，如果当前长度的木棍加入到方案中无法满足要求，则之后的相同长度的木棍都可以跳过<br>3.如果木棒枚举第一根木棍时无法满足要求，则可直接跳过，一定无法满足要求<br>4.同3，如果木棒枚举最后一根木棍时无法满足要求，则可直接跳过<br>可通过反证法证明3.4<br><strong>完整代码如下</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">70</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> sum,length;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> cur,<span class="type">int</span> start)</span></span>&#123;  <span class="comment">//当前组，当前组长度，当前组枚举到的位置</span></span><br><span class="line">    <span class="keyword">if</span>(u * length == sum)<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//总长度达到，返回结果</span></span><br><span class="line">    <span class="keyword">if</span>(cur == length)<span class="keyword">return</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//枚举下一组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i] || cur + w[i] &gt; length)<span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(u,cur + w[i],i + <span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//枚举下一根木棍</span></span><br><span class="line">        st[i] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!cur || cur + w[i] == length)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//3.4</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> j = i;   <span class="comment">//跳过相同长度</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; w[j] == w[i])j++;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n,n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;w[i];</span><br><span class="line">            sum += w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(w,w + n,cmp);  <span class="comment">//优化搜索顺序</span></span><br><span class="line">        </span><br><span class="line">        length = <span class="number">1</span>;   <span class="comment">//外层枚举木棒长度</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum % length == <span class="number">0</span> &amp;&amp; <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))&#123;   <span class="comment">//整除要求</span></span><br><span class="line">                cout&lt;&lt;length&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.828课程之Lab1</title>
    <url>/2023/01/10/MIT6-828%E8%AF%BE%E7%A8%8B%E4%B9%8BLab1/</url>
    <content><![CDATA[<p>先是练手一个控制台输出的小case  </p>
<p>探索了一下堆栈回溯的过程，输出每个eip的函数名，源文件和行号以及位置。<br>行号的输出要自己写一下。</p>
]]></content>
      <categories>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.828课程之环境搭建</title>
    <url>/2023/01/03/MIT6-828%E8%AF%BE%E7%A8%8B%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>6.828：Operating System Engineering</strong><br>操作系统课程实验环境配置教程<br>课程地址：<a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">https://pdos.csail.mit.edu/6.828/2018/schedule.html</a><br>按照labs-&gt;tools中教程进行配置即可，不过用到的很多文件及依赖已经被淘汰了，可能会有一些报错，可参考本文中的解决方法。<br>实验环境选用VMware即可，博主用的腾讯云轻量应用服务器<br>操作系统：Ubuntu Server 20.04 LTS 64bit <span id="more"></span> </p>
<h2 id="Compiler-Toolchain"><a href="#Compiler-Toolchain" class="headerlink" title="Compiler Toolchain"></a>Compiler Toolchain</h2><h3 id="Test-Toolchain"><a href="#Test-Toolchain" class="headerlink" title="Test Toolchain"></a>Test Toolchain</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> objdump -i    <span class="comment">//  second line says elf32-i386</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/03/MIT6-828%E8%AF%BE%E7%A8%8B%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.png">  </p>
<p>测试gcc</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">$ gcc -m32 -<span class="built_in">print</span>-libgcc-<span class="keyword">file</span>-<span class="keyword">name</span> 	</span><br></pre></td></tr></table></figure>
<p>成功则显示<br><img src="/2023/01/03/MIT6-828%E8%AF%BE%E7%A8%8B%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/2.png"></p>
<p>腾讯云搭载了部分基础的应用及依赖，虚拟机新系统可能没有，可运行以下指令安装。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sudo</span> apt-<span class="built_in">get</span> install -y build-essential gdb git vim</span><br><span class="line"><span class="variable">$sudo</span> apt-<span class="built_in">get</span> install gcc-multilib</span><br></pre></td></tr></table></figure>

<h3 id="Build-Toolchain"><a href="#Build-Toolchain" class="headerlink" title="Build Toolchain"></a>Build Toolchain</h3><h4 id="Download-Package"><a href="#Download-Package" class="headerlink" title="Download Package"></a>Download Package</h4><p>官方网站的gmp下载链接可能无法访问，按以下链接下载即可。</p>
<ul>
<li><a href="https://mirrors.sjtug.sjtu.edu.cn/gnu/gmp/gmp-5.0.2.tar.bz2">https://mirrors.sjtug.sjtu.edu.cn/gnu/gmp/gmp-5.0.2.tar.bz2</a></li>
<li><a href="https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2">https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</a></li>
<li><a href="http://www.multiprecision.org/downloads/mpc-0.9.tar.gz">http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</a></li>
<li><a href="http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2">http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</a></li>
<li><a href="http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2">http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</a></li>
<li><a href="http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2">http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</a></li>
</ul>
<p><img src="/2023/01/03/MIT6-828%E8%AF%BE%E7%A8%8B%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/3.png"></p>
<h4 id="Unpack-and-Build"><a href="#Unpack-and-Build" class="headerlink" title="Unpack and Build"></a>Unpack and Build</h4><h5 id="Install-gmp-5-0-2"><a href="#Install-gmp-5-0-2" class="headerlink" title="Install gmp-5.0.2"></a>Install gmp-5.0.2</h5><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$tar</span> xjf gmp-5.0.2.tar.bz2</span></span><br><span class="line"><span class="meta"><span class="keyword">$cd</span> gmp-5.0.2</span></span><br><span class="line"><span class="symbol">$</span>./configure --prefix=/usr/local</span><br><span class="line"><span class="meta"><span class="keyword">$make</span></span></span><br><span class="line"><span class="meta"><span class="keyword">$sudo</span> make install             </span></span><br><span class="line"><span class="meta"><span class="keyword">$cd</span> ..</span></span><br></pre></td></tr></table></figure>
<p>若第三条指令显示No usable m4 in $PATH or &#x2F;usr&#x2F;5bin是缺失库文件，执行以下指令再重新执行第三条指令。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$sudo</span> apt install m4</span></span><br></pre></td></tr></table></figure>
<h5 id="Install-mpfr-3-1-2"><a href="#Install-mpfr-3-1-2" class="headerlink" title="Install mpfr-3.1.2"></a>Install mpfr-3.1.2</h5><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$tar</span> xjf mpfr-3.1.2.tar.bz2</span></span><br><span class="line"><span class="meta"><span class="keyword">$cd</span> mpfr-3.1.2</span></span><br><span class="line"><span class="symbol">$</span>./configure --prefix=/usr/local</span><br><span class="line"><span class="meta"><span class="keyword">$make</span></span></span><br><span class="line"><span class="meta"><span class="keyword">$sudo</span> make install           </span></span><br><span class="line"><span class="meta"><span class="keyword">$cd</span> ..</span></span><br></pre></td></tr></table></figure>
<h5 id="Install-mpc-0-9"><a href="#Install-mpc-0-9" class="headerlink" title="Install mpc-0.9"></a>Install mpc-0.9</h5><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$tar</span> xzf mpc-0.9.tar.gz</span></span><br><span class="line"><span class="meta"><span class="keyword">$cd</span> mpc-0.9</span></span><br><span class="line"><span class="symbol">$</span>./configure --prefix=/usr/local</span><br><span class="line"><span class="meta"><span class="keyword">$make</span></span></span><br><span class="line"><span class="meta"><span class="keyword">$sudo</span> make install            </span></span><br><span class="line"><span class="meta"><span class="keyword">$cd</span> ..</span></span><br></pre></td></tr></table></figure>
<h5 id="Install-binutils-2-21-1"><a href="#Install-binutils-2-21-1" class="headerlink" title="Install binutils-2.21.1"></a>Install binutils-2.21.1</h5><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$tar</span> xjf binutils-2.21.1.tar.bz2</span></span><br><span class="line"><span class="meta"><span class="keyword">$cd</span> binutils-2.21.1</span></span><br><span class="line"><span class="symbol">$</span>./configure --prefix=/usr/local --target=i386-jos-elf --disable-werror</span><br><span class="line"><span class="meta"><span class="keyword">$make</span></span></span><br><span class="line"><span class="meta"><span class="keyword">$sudo</span> make install             </span></span><br><span class="line"><span class="meta"><span class="keyword">$cd</span> ..</span></span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$i386</span>-jos-elf-objdump -i</span></span><br></pre></td></tr></table></figure>
<p>安装成功则输出以下信息<br><img src="/2023/01/03/MIT6-828%E8%AF%BE%E7%A8%8B%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/4.png"></p>
<h5 id="Install-gcc-core-4-6-4"><a href="#Install-gcc-core-4-6-4" class="headerlink" title="Install gcc-core-4.6.4"></a>Install gcc-core-4.6.4</h5><p>gcc需要单独的目录否则编译不成功</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="variable">$tar</span> xjf gcc-core-<span class="number">4.6</span>.<span class="number">4</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span></span><br><span class="line"><span class="variable">$cd</span> gcc-<span class="number">4.6</span>.<span class="number">4</span></span><br><span class="line"><span class="variable">$mkdir</span> build           </span><br><span class="line"><span class="variable">$cd</span> build</span><br><span class="line">$../configure <span class="attr">--prefix</span>=/usr/local \</span><br><span class="line">    <span class="attr">--target</span>=i386-jos-elf <span class="attr">--disable-werror</span> \</span><br><span class="line">    <span class="attr">--disable-libssp</span> <span class="attr">--disable-libmudflap</span> <span class="attr">--with-newlib</span> \</span><br><span class="line">    <span class="attr">--without-headers</span> <span class="attr">--enable-languages</span>=c MAKEINFO=missing</span><br><span class="line"><span class="variable">$make</span> <span class="attribute">all</span>-gcc</span><br><span class="line"><span class="variable">$sudo</span> make install-gcc         </span><br><span class="line"><span class="variable">$make</span> <span class="attribute">all</span>-target-libgcc		</span><br><span class="line"><span class="variable">$sudo</span> make install-target-libgcc   </span><br><span class="line"><span class="variable">$cd</span> ../..</span><br></pre></td></tr></table></figure>
<p>若第八条指令报错configure-target-libgcc<br><img src="/2023/01/03/MIT6-828%E8%AF%BE%E7%A8%8B%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/5.png"><br>则执行以下命令后重新执行第八条指令</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$export</span> <span class="title class_">LD_LIBRARY_PATH</span>=<span class="variable">$LD_LIBRARY_PATH</span><span class="symbol">:/usr/local/lib</span> </span><br></pre></td></tr></table></figure>
<p>测试安装结果</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$i386</span>-jos-elf-gcc -v</span></span><br></pre></td></tr></table></figure>
<p>成功后输出以下信息<br><img src="/2023/01/03/MIT6-828%E8%AF%BE%E7%A8%8B%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/6.png">  </p>
<h5 id="Install-gdb-7-3-1"><a href="#Install-gdb-7-3-1" class="headerlink" title="Install gdb-7.3.1"></a>Install gdb-7.3.1</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="variable">$tar</span> xjf gdb-<span class="number">7.3</span>.<span class="number">1</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span></span><br><span class="line"><span class="variable">$cd</span> gdb-<span class="number">7.3</span>.<span class="number">1</span></span><br><span class="line">$./configure <span class="attr">--prefix</span>=/usr/local <span class="attr">--target</span>=i386-jos-elf <span class="attr">--program-prefix</span>=i386-jos-elf- \</span><br><span class="line">    <span class="attr">--disable-werror</span></span><br><span class="line"><span class="variable">$make</span> <span class="attribute">all</span>			 </span><br><span class="line"><span class="variable">$sudo</span> make install         </span><br><span class="line"><span class="variable">$cd</span> ..</span><br></pre></td></tr></table></figure>
<p>若第四条指令报错no termcap library found，缺少库文件，执行以下指令安装termcap后重新执行。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$wget</span> http://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span></span><br><span class="line"><span class="meta"><span class="keyword">$tar</span> -zxv -f termcap-1.3.1.tar.gz</span></span><br><span class="line"><span class="meta"><span class="keyword">$cd</span> termcap-1.3.1</span></span><br><span class="line"><span class="symbol">$</span> ./configure </span><br><span class="line"><span class="meta"><span class="keyword">$make</span></span></span><br><span class="line"><span class="meta"><span class="keyword">$sudo</span> make install</span></span><br></pre></td></tr></table></figure>
<h2 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h2><p>QEMU是一种现代且快速的 PC 模拟器，828课程要求该课程定制的QEMU版本。<br>直接用官方教程中的指令可能会报错，可以尝试更换python版本。</p>
<h3 id="Install-Tools"><a href="#Install-Tools" class="headerlink" title="Install Tools"></a>Install Tools</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$sudo</span> apt install libsdl1.2-dev libtool-bin libglib2.0-dev  libz-dev  libpixman-1-dev</span></span><br><span class="line"><span class="meta"><span class="keyword">$sudo</span> apt install python2</span></span><br></pre></td></tr></table></figure>
<p>若执行第一条指令后发现apt,git等指令无法正常使用，报错undefined symbol: __gmpz_limbs_write，则执行以下指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cd</span> /usr/local/lib</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">rm</span> libgmp*</span></span><br></pre></td></tr></table></figure>
<h3 id="Install-QEMU"><a href="#Install-QEMU" class="headerlink" title="Install QEMU"></a>Install QEMU</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/mit-pdos/</span><span class="number">6.828</span>-qemu.git qemu</span><br><span class="line">$.<span class="regexp">/configure --disable-kvm --disable-werror --prefix=/u</span>sr/local  --target-list=<span class="string">&quot;i386-softmmu x86_64-softmmu&quot;</span> --python=python2</span><br><span class="line"><span class="variable">$make</span></span><br><span class="line"><span class="variable">$sudo</span> make install</span><br></pre></td></tr></table></figure>
<p>遇到报错如下：<br><img src="/2023/01/03/MIT6-828%E8%AF%BE%E7%A8%8B%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/7.png"><br>解决方法：在 qga&#x2F;commands-posix.c文件中的 #include &lt;sys&#x2F;types.h&gt; 下面增加#include &lt;sys&#x2F;sysmacros.h&gt;</p>
<h3 id="Test-QEMU"><a href="#Test-QEMU" class="headerlink" title="Test QEMU"></a>Test QEMU</h3><p>下载实验源码进行测试</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> clone https:<span class="regexp">//</span>pdos.csail.mit.edu<span class="regexp">/6.828/</span><span class="number">2018</span>/jos.git lab</span><br><span class="line"><span class="variable">$cd</span> lab</span><br><span class="line"><span class="variable">$make</span></span><br><span class="line"><span class="variable">$make</span> qemu-nox</span><br></pre></td></tr></table></figure>
<p>测试成功界面<br><img src="/2023/01/03/MIT6-828%E8%AF%BE%E7%A8%8B%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/8.png"></p>
]]></content>
      <categories>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>golang学习-即时通讯系统demo</title>
    <url>/2023/01/01/golang%E5%AD%A6%E4%B9%A0-%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9Fdemo/</url>
    <content><![CDATA[<h1 id="简易的即时通讯系统的模拟demo"><a href="#简易的即时通讯系统的模拟demo" class="headerlink" title="简易的即时通讯系统的模拟demo"></a>简易的即时通讯系统的模拟demo</h1><p>基本项目结构如下<br><img src="/2023/01/01/golang%E5%AD%A6%E4%B9%A0-%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9Fdemo/tree.png"><br>项目地址： <a href="https://github.com/Vector-DY/Instant-Messaging-demo">https://github.com/Vector-DY/Instant-Messaging-demo</a></p>
<span id="more"></span>
<h2 id="server构建"><a href="#server构建" class="headerlink" title="server构建"></a>server构建</h2><p>定义基本server类型及服务器接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	Ip   <span class="type">string</span></span><br><span class="line">	Port <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(ip <span class="type">string</span>, port <span class="type">int</span>)</span></span> *Server &#123;</span><br><span class="line">	server := &amp;Server&#123;</span><br><span class="line">		Ip:        ip,</span><br><span class="line">		Port:      port,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Start() &#123;</span><br><span class="line">	<span class="comment">//socket listen</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, s.Ip, s.Port))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;net.Listen err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//close listen socket</span></span><br><span class="line">	<span class="keyword">defer</span> listener.Close(）</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//accept</span></span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;listener accept err:&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">///do handler</span></span><br><span class="line">		<span class="keyword">go</span> s.Handler(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h2><h3 id="用户结构构建"><a href="#用户结构构建" class="headerlink" title="用户结构构建"></a>用户结构构建</h3><p>用户板块结构如下图所示<br>使用Map记录在线用户信息，用户上线后向服务器发出请求，服务器为每一个用户分配单独的channel传递消息<br><img src="/2023/01/01/golang%E5%AD%A6%E4%B9%A0-%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9Fdemo/user.png"><br>用户对象及方法定义如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">User</span> <span class="title">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Addr <span class="keyword">string</span></span><br><span class="line">	C    chan <span class="keyword">string</span>  </span><br><span class="line">	conn net.Conn //用户属于哪一个连接</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewUser(conn net.Conn) *<span class="keyword">User</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">	userAddr</span> := conn.RemoteAddr().<span class="keyword">String</span>()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">user</span> <span class="title">:= &amp;User</span>&#123;</span><br><span class="line">		Name: userAddr,</span><br><span class="line">		Addr: userAddr,</span><br><span class="line">		C:    make(chan <span class="keyword">string</span>),</span><br><span class="line">		conn: conn,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//启动监听当前<span class="keyword">user</span> <span class="title">channel</span>消息的goroutine</span><br><span class="line">	go user.ListenMessage()</span><br><span class="line"></span><br><span class="line">	return <span class="keyword">user</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<p>服务器端需要增添存储用户数据的数据结构及处理用户业务的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	Ip   <span class="type">string</span></span><br><span class="line">	Port <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//在线用户列表</span></span><br><span class="line">	OnlineMap <span class="keyword">map</span>[<span class="type">string</span>]*User</span><br><span class="line">	mapLock   sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">//消息广播的channel</span></span><br><span class="line">	Message <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Handler(conn net.Conn) &#123;&#125;</span><br><span class="line"><span class="comment">//广播消息的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> BroadCast(user *User, msg <span class="type">string</span>) &#123;</span><br><span class="line">	sendMsg := <span class="string">&quot;[&quot;</span> + user.Addr + <span class="string">&quot;]&quot;</span> + user.Name + <span class="string">&quot;:&quot;</span> + msg</span><br><span class="line">	s.Message &lt;- sendMsg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听Message广播消息channel的goroutine,一旦有消息就发送给全部的在线User</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> ListenMessager() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		msg := &lt;-s.Message</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将msg发送给全部的在线User</span></span><br><span class="line">		s.mapLock.Lock()</span><br><span class="line">		<span class="keyword">for</span> _, cli := <span class="keyword">range</span> s.OnlineMap &#123;</span><br><span class="line">			cli.C &lt;- msg</span><br><span class="line">		&#125;</span><br><span class="line">		s.mapLock.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在服务器监听程序中，可以单独开辟一个goroutine监听Message广播消息</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>启动监听Message的goroutine</span><br><span class="line">	go s.ListenMessager()</span><br></pre></td></tr></table></figure>
<h3 id="用户业务层封装"><a href="#用户业务层封装" class="headerlink" title="用户业务层封装"></a>用户业务层封装</h3><p>一些消息方法我们之前运行在了server当中,所以需要将在server中处理的用户业务封装入用户模块,降低程序的耦合性。<br>在用户对象中加入server属性,表示所关联的服务器,处理用户在服务端的业务。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">	Addr string</span><br><span class="line">	C    chan string</span><br><span class="line">	conn net<span class="selector-class">.Conn</span></span><br><span class="line"></span><br><span class="line">	server *Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户的上线业务</span></span><br><span class="line">func (u *User) <span class="built_in">Online</span>() &#123;</span><br><span class="line">	<span class="comment">//用户上线,将用户加入到OnlineMap中</span></span><br><span class="line">	u<span class="selector-class">.server</span><span class="selector-class">.mapLock</span><span class="selector-class">.Lock</span>()</span><br><span class="line">	u<span class="selector-class">.server</span><span class="selector-class">.OnlineMap</span><span class="selector-attr">[u.Name]</span> = u</span><br><span class="line">	u<span class="selector-class">.server</span><span class="selector-class">.mapLock</span><span class="selector-class">.Unlock</span>()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//广播当前用户上线信息</span></span><br><span class="line">	u<span class="selector-class">.server</span><span class="selector-class">.BroadCast</span>(u, <span class="string">&quot;已上线&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用户的下线业务</span></span><br><span class="line">func (u *User) <span class="built_in">Offline</span>() &#123;</span><br><span class="line">	<span class="comment">//用户下线,将用户从OnlineMap中删除</span></span><br><span class="line">	u<span class="selector-class">.server</span><span class="selector-class">.mapLock</span><span class="selector-class">.Lock</span>()</span><br><span class="line">	<span class="built_in">delete</span>(u<span class="selector-class">.server</span><span class="selector-class">.OnlineMap</span>, u.Name)</span><br><span class="line">	u<span class="selector-class">.server</span><span class="selector-class">.mapLock</span><span class="selector-class">.Unlock</span>()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//广播当前用户上线信息</span></span><br><span class="line">	u<span class="selector-class">.server</span><span class="selector-class">.BroadCast</span>(u, <span class="string">&quot;已下线&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用户的消息业务</span></span><br><span class="line">func (u *User) <span class="built_in">DoMessage</span>(msg string) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用户功能扩展"><a href="#用户功能扩展" class="headerlink" title="用户功能扩展"></a>用户功能扩展</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给当前User对应的客户端发送消息</span></span><br><span class="line"><span class="comment">// 通过指令处理用户请求</span></span><br><span class="line">func (u *User) <span class="constructor">SendMsg(<span class="params">msg</span> <span class="params">string</span>)</span> &#123;</span><br><span class="line">	u.conn.<span class="constructor">Write([]<span class="params">byte</span>(<span class="params">msg</span>)</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在线用户查询功能。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> msg == <span class="string">&quot;who&quot;</span> &#123;</span><br><span class="line">	<span class="comment">//查询当前在线用户</span></span><br><span class="line">	u<span class="selector-class">.server</span><span class="selector-class">.mapLock</span><span class="selector-class">.Lock</span>()</span><br><span class="line">	<span class="keyword">for</span> _, user := range u<span class="selector-class">.server</span><span class="selector-class">.OnlineMap</span> &#123;</span><br><span class="line">		onlineMsg := <span class="string">&quot;[&quot;</span> + user<span class="selector-class">.Addr</span> + <span class="string">&quot;]&quot;</span> + user<span class="selector-class">.Name</span> + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;在线...\n&quot;</span></span><br><span class="line">		u<span class="selector-class">.SendMsg</span>(onlineMsg)</span><br><span class="line">	&#125;</span><br><span class="line">	u<span class="selector-class">.server</span><span class="selector-class">.mapLock</span><span class="selector-class">.Unlock</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改名功能</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(msg) &gt; <span class="number">7</span> &amp;&amp; msg<span class="selector-attr">[:7]</span> == <span class="string">&quot;rename|&quot;</span> &#123;</span><br><span class="line">	<span class="comment">//消息格式：rename|XX</span></span><br><span class="line">	newName := strings<span class="selector-class">.Split</span>(msg, <span class="string">&quot;|&quot;</span>)<span class="selector-attr">[1]</span></span><br><span class="line">	<span class="comment">//判断name是否存在</span></span><br><span class="line">	_, ok := u<span class="selector-class">.server</span><span class="selector-class">.OnlineMap</span><span class="selector-attr">[newName]</span></span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		u<span class="selector-class">.SendMsg</span>(<span class="string">&quot;当前用户名被使用\n&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		u<span class="selector-class">.server</span><span class="selector-class">.mapLock</span><span class="selector-class">.Lock</span>()</span><br><span class="line">		<span class="built_in">delete</span>(u<span class="selector-class">.server</span><span class="selector-class">.OnlineMap</span>, u.Name)</span><br><span class="line">		u<span class="selector-class">.server</span><span class="selector-class">.OnlineMap</span><span class="selector-attr">[newName]</span> = u</span><br><span class="line">		u<span class="selector-class">.server</span><span class="selector-class">.mapLock</span><span class="selector-class">.Unlock</span>()</span><br><span class="line"></span><br><span class="line">		u<span class="selector-class">.Name</span> = newName</span><br><span class="line">		u<span class="selector-class">.SendMsg</span>(<span class="string">&quot;您已更新用户名&quot;</span> + u<span class="selector-class">.Name</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超时离线功能<br>在服务器的阻塞执行进程中判断用户是否在线</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听用户是否活跃的channel</span></span><br><span class="line">isLive := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-isLive:</span><br><span class="line">		<span class="comment">//当前用户是活跃的,应该重置定时器</span></span><br><span class="line">		<span class="comment">//不做任何事情,激活select,更新下边定时器</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After((time.Second * <span class="number">120</span>)):</span><br><span class="line">		<span class="comment">//已经超时</span></span><br><span class="line">		<span class="comment">//将当前Use强制关闭</span></span><br><span class="line">		user.SendMsg(<span class="string">&quot;登录已超时&quot;</span>)</span><br><span class="line">		<span class="comment">//注销资源</span></span><br><span class="line">		<span class="built_in">close</span>(user.C)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//关闭连接</span></span><br><span class="line">		conn.Close()</span><br></pre></td></tr></table></figure>
<p>私聊功能<br>获取对方的用户对象信息并发送信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(msg) &gt; <span class="number">4</span> &amp;&amp; msg[:<span class="number">3</span>] == <span class="string">&quot;to|&quot;</span> &#123;</span><br><span class="line">	<span class="comment">//消息格式 to|XX|msg</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1 获取对方用户名</span></span><br><span class="line">	remoteName := strings.Split(msg, <span class="string">&quot;|&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">if</span> remoteName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		u.SendMsg(<span class="string">&quot;usage : to|XX|msg \n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 根据用户名得到User对象</span></span><br><span class="line">	remoteUser, ok := u.server.OnlineMap[remoteName]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		u.SendMsg(<span class="string">&quot;该用户名不存在\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3 获取消息内容,通过对方的User对象将消息内容发送给过去</span></span><br><span class="line">	content := strings.Split(msg, <span class="string">&quot;|&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="keyword">if</span> content == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		u.SendMsg(<span class="string">&quot;无内容，请重发\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	remoteUser.SendMsg(u.Name + <span class="string">&quot;对你说：&quot;</span> + content + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>处理用户输入,与服务端交互。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	ServerIp   <span class="type">string</span></span><br><span class="line">	ServerPort <span class="type">int</span></span><br><span class="line">	Name       <span class="type">string</span></span><br><span class="line">	conn       net.Conn</span><br><span class="line">	flag       <span class="type">int</span> <span class="comment">//当前客户端模式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;serverIp, <span class="string">&quot;ip&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;服务器IP地址(默认为127.0.0.1)&quot;</span>)</span><br><span class="line">	flag.IntVar(&amp;serverPort, <span class="string">&quot;port&quot;</span>, <span class="number">8888</span>, <span class="string">&quot;服务器端口(默认为8888)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//命令行解析</span></span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	client := NewClient(serverIp, serverPort)</span><br><span class="line">	<span class="keyword">if</span> client == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;连接服务器失败...&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//单独开启一个goroutine处理server的回执消息</span></span><br><span class="line">	<span class="keyword">go</span> client.DealResponse()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;连接服务器成功...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//启动客户端的业务</span></span><br><span class="line">	client.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>instant-messaging</tag>
      </tags>
  </entry>
  <entry>
    <title>happynewyear</title>
    <url>/2022/12/31/happynewyear/</url>
    <content><![CDATA[<p>苏轼有句话：“犯其至难而图其至远”，意思是说“向最难之处攻坚，追求最远大的目标”。路虽远，行则将至；事虽难，做则必成。只要有愚公移山的志气、滴水穿石的毅力，脚踏实地，埋头苦干，积跬步以至千里，就一定能够把宏伟目标变为美好现实。<br>新年的钟声即将敲响，让我们怀着对未来的美好向往，共同迎接2023年的第一缕阳光。<br>祝愿祖国繁荣昌盛、国泰民安！祝愿世界和平美好、幸福安宁！祝愿大家新年快乐、皆得所愿！ </p>
]]></content>
  </entry>
  <entry>
    <title>mem类函数模拟</title>
    <url>/2023/03/16/mem%E7%B1%BB%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>模拟实现memcpy函数<br>主要注意内存踩踏的处理  </p>
<h3 id="memcopy"><a href="#memcopy" class="headerlink" title="memcopy"></a>memcopy</h3><p>库函数自带的memcpy只需一个字节一个字节复制即可   <span id="more"></span> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mymemcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((dest == <span class="literal">nullptr</span>) || (src == <span class="literal">nullptr</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> *res = dest;</span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">char</span> *)dest = *(<span class="type">char</span> *)src;</span><br><span class="line">        dest = (<span class="type">char</span> *)dest + <span class="number">1</span>;</span><br><span class="line">        src = (<span class="type">char</span> *)src + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下几个指针的使用，第一次看到这种语法的时候也比较迷惑。<br>void *是类型未定的指针，算是一种泛型，复制时用char *指针将每个字节复制。  </p>
<h3 id="memmove"><a href="#memmove" class="headerlink" title="memmove"></a>memmove</h3><p>当有内存重叠的情况发生时，memcopy不能正确完成拷贝，而memmove可以正确处理。<br>从后往前拷贝即可。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mymemmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((dest == <span class="literal">nullptr</span>) || (src == <span class="literal">nullptr</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> *res = dest;</span><br><span class="line">    <span class="keyword">if</span> (dest &lt; src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (count--)</span><br><span class="line">        &#123;</span><br><span class="line">            *(<span class="type">char</span> *)dest = *(<span class="type">char</span> *)src;</span><br><span class="line">            dest = (<span class="type">char</span> *)dest + <span class="number">1</span>;</span><br><span class="line">            src = (<span class="type">char</span> *)src + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (count--)</span><br><span class="line">        &#123;</span><br><span class="line">            *((<span class="type">char</span> *)dest + count) = *((<span class="type">char</span> *)src + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><p>除此外还有memset填充和memcmp比较函数，与memcpy类似实现即可</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mymemset</span><span class="params">(<span class="type">void</span> *dest, <span class="type">int</span> val, <span class="type">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(dest);</span><br><span class="line">    <span class="type">void</span> *res = dest;</span><br><span class="line">    <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">        *(<span class="type">char</span> *)dest = val;</span><br><span class="line">        dest = (<span class="type">char</span> *)dest + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp"></a>memcmp</h3><p>char*是有符号的，如果大于127即0x7F的数就是负数了,需要注意。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mymemcpy</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(str1);</span><br><span class="line">    <span class="built_in">assert</span>(str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count-- &amp;&amp; *(<span class="type">char</span> *)str1 == *(<span class="type">char</span> *)str2) &#123;</span><br><span class="line">        str1 = (<span class="type">char</span> *)str1 + <span class="number">1</span>;</span><br><span class="line">        str2 = (<span class="type">char</span> *)str2 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)str1 - *(<span class="type">unsigned</span> <span class="type">char</span> *)str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>newpapaername</title>
    <url>/2022/12/31/newpapaername/</url>
    <content><![CDATA[<h1 id="test-hexo"><a href="#test-hexo" class="headerlink" title="test hexo"></a>test hexo</h1><pre><code>fum main()&#123;
    print(&quot;hello hexo&quot;)
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>nvim安装及配置</title>
    <url>/2023/07/10/nvim%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>到neovim的wiki界面找stable release通过tarball安装<br><a href="https://github.com/neovim/neovim/releases/tag/stable">https://github.com/neovim/neovim/releases/tag/stable</a></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sudo</span> tar xzvf nvim-linux64.tar.gz</span><br><span class="line"><span class="variable">$sudo</span> mv nvim-linux64 <span class="regexp">/usr/</span>local/nvim</span><br><span class="line"><span class="comment">#创建快捷方式 软链接</span></span><br><span class="line"><span class="variable">$sudo</span> ln -s <span class="regexp">/usr/</span>local<span class="regexp">/nvim/</span>bin<span class="regexp">/nvim /u</span>sr<span class="regexp">/bin/</span>nvim</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">mkdir</span> -p .config/nvim</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">touch</span> init.lua</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">mkdir</span> lua</span></span><br></pre></td></tr></table></figure>

<p>首先配置packer</p>
<p><a href="https://github.com/wbthomason/packer.nvim">https://github.com/wbthomason/packer.nvim</a><br><a href="https://github.com/folke/tokyonight.nvim">https://github.com/folke/tokyonight.nvim</a><br><a href="https://github.com/nvim-lualine/lualine.nvim">https://github.com/nvim-lualine/lualine.nvim</a><br><a href="https://github.com/nvim-tree/nvim-tree.lua">https://github.com/nvim-tree/nvim-tree.lua</a></p>
<p><img src="/2023/07/10/nvim%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/1.png"></p>
]]></content>
      <categories>
        <category>nvim</category>
      </categories>
      <tags>
        <tag>nvim</tag>
      </tags>
  </entry>
  <entry>
    <title>《Go语言编程》笔记之音乐盒demo</title>
    <url>/2023/01/01/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%9F%B3%E4%B9%90%E7%9B%92demo/</url>
    <content><![CDATA[<p>本文为《Go语言编程》第三章所描述的示例实现,主要演示并总结Go语言面向对象编程特性。<br>Go语言的面向对象特性设计简洁,通过接口的设计,摒弃了继承、构造、析构、虚函数等臃肿的机制。<br>Go语言的接口并不是其他语言（C++、Java、C#等）中所提供的接口概念，在Go语言出现之前，接口主要作为不同组件之间的契约存在。对契约的实现是强制的，你必须声明你的确实现了该接口。为了实现一个接口，你需要从该接口继承所有的方法，即使另外有一个接口实现了与该接口完全一样的接口方法甚至名字也相同只不过位于不同的名字空间下，编译器也会认为上面的类只实现了该接口而没有实现定义相同的那个接口。这类接口我们称为侵入式接口。“侵入式”的主要表现在于实现类需要明确声明自己实现了某个接口。这种强制性的接口继承是面向对象编程思想发展过程中一个遭受相当多置疑的特性。<br>在Go语言中，一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口。Go语言在接口上的调整有以下三个优点：<br>其一，Go语言的标准库，再也不需要绘制类库的继承树图。你一定见过不少C++、Java、C#类库的继承树图。在Go中，类的继承树并无意义，你只需要知道这个类实现了哪些方法，每个方法是什么含义，就足够了。<br>其二，实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理。接口由使用方按需定义，而不用事前规划。<br>其三，不用为了实现一个接口而导入一个包，因为多引用一个外部的包，就意味着更多的耦合。接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口。<br>了解了Go语言面向对象的特性之后，可以通过一个音乐盒的小示例来深刻感受。<br>demo地址:<a href="https://github.com/Vector-DY/gostudy/tree/main/musicplayer">https://github.com/Vector-DY/gostudy/tree/main/musicplayer</a></p>
<span id="more"></span>
<p>文件结构<br><img src="/2023/01/01/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%9F%B3%E4%B9%90%E7%9B%92demo/tree.png"><br>实际效果<br><img src="/2023/01/01/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%9F%B3%E4%B9%90%E7%9B%92demo/demo.png"></p>
<h2 id="音乐库管理"><a href="#音乐库管理" class="headerlink" title="音乐库管理"></a>音乐库管理</h2><p>首先先来定义音乐信息的结构体</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> MusicEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id     <span class="keyword">string</span></span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Artist <span class="keyword">string</span></span><br><span class="line">	Source <span class="keyword">string</span></span><br><span class="line">	<span class="built_in">Type</span>   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后实现具体的类型方法，我们使用一个数组切片作为基础存储结构，其他<br>的操作都只是对这个数组切片的包装</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MusicManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	musics []MusicEntry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMusicManager</span><span class="params">()</span></span> *MusicManager &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MusicManager&#123;<span class="built_in">make</span>([]MusicEntry, <span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MusicManager)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m.musics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MusicManager)</span></span> Get(index <span class="type">int</span>) (music *MusicEntry, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">len</span>(m.musics) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Index out of range.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;m.musics[index], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本增删查改操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MusicManager)</span></span> Find(name <span class="type">string</span>) *MusicEntry &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(m.musics) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> m.musics &#123;</span><br><span class="line">		<span class="keyword">if</span> m.Name == name &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;m</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MusicManager)</span></span> Add(music *MusicEntry) &#123;</span><br><span class="line">	m.musics = <span class="built_in">append</span>(m.musics, *music)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MusicManager)</span></span> Remove(index <span class="type">int</span>) *MusicEntry &#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">len</span>(m.musics) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	removedMusic := &amp;m.musics[index]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="built_in">len</span>(m.musics)<span class="number">-1</span> &#123;</span><br><span class="line">		m.musics = <span class="built_in">append</span>(m.musics[:index<span class="number">-1</span>], m.musics[index+<span class="number">1</span>:]...)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">		m.musics = <span class="built_in">make</span>([]MusicEntry, <span class="number">0</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m.musics = m.musics[:index<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> removedMusic</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MusicManager)</span></span> RemoveByName(name <span class="type">string</span>) *MusicEntry &#123;</span><br><span class="line">	index := <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> i, item := <span class="keyword">range</span> m.musics &#123;</span><br><span class="line">		<span class="keyword">if</span> item.Name == name &#123;</span><br><span class="line">			index = i</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> index == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m.Remove(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="音乐播放模块"><a href="#音乐播放模块" class="headerlink" title="音乐播放模块"></a>音乐播放模块</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Player interface &#123;</span><br><span class="line">	<span class="constructor">Play(<span class="params">source</span> <span class="params">string</span>)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="constructor">Play(<span class="params">source</span>, <span class="params">mtype</span> <span class="params">string</span>)</span> &#123;</span><br><span class="line">	var p Player</span><br><span class="line">	p.<span class="constructor">Play(<span class="params">source</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id><a href="#" class="headerlink" title></a></h2><p>简单的小示例，自行编写main函数编译运行即可，重在理解音乐库管理中的面向对象特性。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>判断点在多边形内部</title>
    <url>/2023/07/21/%E5%88%A4%E6%96%AD%E7%82%B9%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8/</url>
    <content><![CDATA[<p>中望的内推人说笔试可能会出判断点在多边形内部。<br>如果从点P作水平向左的射线的话，假设P在多边形内部，那么这条射线与多边形的交点必为奇数，如果P在多边形外部，则交点个数必为偶数（0也在内）。<br>所以，我们可以遍历多边形的每条边，求出交点的总个数。<br>比较特殊的情况是如果射线正好穿过两条边之间,那么这个交点会被算作2次，处理办法是可以规定线段的两个端点中每个端点只属于其中一条线。  </p>
<span id="more"></span>  
<p>参考论文<a href="https://blog.csdn.net/hjh2005/article/details/9246967">https://blog.csdn.net/hjh2005/article/details/9246967</a><br>参考论文<a href="https://www.cnblogs.com/reedlau/p/5731846.html">https://www.cnblogs.com/reedlau/p/5731846.html</a><br>求交点参考直线的两点式方程</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> namespace std;</span><br><span class="line">struct <span class="type">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="type">Point</span>() &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Point</span>(<span class="type">double</span> _x, <span class="type">double</span> _y) &#123;</span><br><span class="line">        x = _x;</span><br><span class="line">        y = _y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> pointInPolygon(<span class="type">Point</span> p, vector&lt;<span class="type">Point</span>&gt;&amp; <span class="type">Polygon</span>, <span class="type">int</span> nCount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nCross = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nCount; i++) &#123;</span><br><span class="line">        <span class="type">Point</span> p1 = <span class="type">Polygon</span>[i];</span><br><span class="line">        <span class="type">Point</span> p2 = <span class="type">Polygon</span>[(i + <span class="number">1</span>) % nCount];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p1.y == p2.y) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.y &lt; min(p1.y, p2.y)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.y &gt;= max(p1.y, p2.y)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> x = (<span class="type">double</span>)(p.y - p1.y) * (<span class="type">double</span>)(p2.x - p1.x) / (<span class="type">double</span>)(p2.y - p1.y) + p1.x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; p.x) &#123;</span><br><span class="line">            nCross++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nCross % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">Point</span>&gt; p;</span><br><span class="line">    p.push_back(<span class="type">Point</span>(<span class="number">268.28</span>, <span class="number">784.75</span>));</span><br><span class="line">	p.push_back(<span class="type">Point</span>(<span class="number">153.98</span>, <span class="number">600.60</span>));</span><br><span class="line">	p.push_back(<span class="type">Point</span>(<span class="number">274.63</span>, <span class="number">336.02</span>));</span><br><span class="line">	p.push_back(<span class="type">Point</span>(<span class="number">623.88</span>, <span class="number">401.64</span>));</span><br><span class="line">	p.push_back(<span class="type">Point</span>(<span class="number">676.80</span>, <span class="number">634.47</span>));</span><br><span class="line">	p.push_back(<span class="type">Point</span>(<span class="number">530.75</span>, <span class="number">822.85</span>));</span><br><span class="line">	p.push_back(<span class="type">Point</span>(<span class="number">268.28</span>, <span class="number">784.75</span>));</span><br><span class="line">    <span class="type">Point</span> test1;</span><br><span class="line">    <span class="type">Point</span> test2;</span><br><span class="line">    <span class="type">Point</span> test3;</span><br><span class="line">    test1.x = <span class="number">407.98</span>, test1.y = <span class="number">579.43</span>; </span><br><span class="line">    test2.x = <span class="number">678.92</span>, test2.y = <span class="number">482.07</span>;</span><br><span class="line">    test3.x = <span class="number">268.28</span>, test3.y = <span class="number">784.75</span>;</span><br><span class="line">    cout &lt;&lt; pointInPolygon(test1, p, <span class="number">7</span>) &lt;&lt; &quot; &quot; &lt;&lt; pointInPolygon(test2, p, <span class="number">7</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pointInPolygon(test3, p, <span class="number">7</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串题目处理方法</title>
    <url>/2023/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E7%9B%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>最近两天碰到几道字符串题目，总结记录一下通用的方法，C++要自己写切片函数搞字符串还是有点麻烦，python或者go会更方便一点。</p>
<span id="more"></span>  
<h3 id="切片函数"><a href="#切片函数" class="headerlink" title="切片函数"></a>切片函数</h3><p>一般按空格划分，当碰到类似于单词匹配时可以用来存储每个单词子串，再借助哈希表来求解。</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; <span class="keyword">split</span>(string &amp;<span class="keyword">str</span>,char target)&#123;</span><br><span class="line">        vector&lt;string&gt; res<span class="comment">;</span></span><br><span class="line">        string s(<span class="keyword">str</span>)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">pos</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">pos</span> &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">pos</span> &lt; s.size() &amp;&amp; s[<span class="keyword">pos</span>] == target)&#123;</span><br><span class="line">                <span class="keyword">pos</span>++<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> start = <span class="keyword">pos</span><span class="comment">;</span></span><br><span class="line">             <span class="keyword">while</span> (<span class="keyword">pos</span> &lt; s.size() &amp;&amp; s[<span class="keyword">pos</span>] != target) &#123;</span><br><span class="line">                <span class="keyword">pos</span>++<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">pos</span> &gt; start)&#123;</span><br><span class="line">                res.emplace_back(s.substr(start,<span class="keyword">pos</span> - start))<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res<span class="comment">;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><h4 id="Leetcode-1813-句子相似性Ⅲ"><a href="#Leetcode-1813-句子相似性Ⅲ" class="headerlink" title="Leetcode.1813 句子相似性Ⅲ"></a>Leetcode.1813 句子相似性Ⅲ</h4><p>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，”Hello World”，”HELLO”，”hello world hello world”都是句子。每个单词都只包含大写和小写英文字母。<br>如果两个句子sentence1和sentence2，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是相似的 。比方说，sentence1 &#x3D; “Hello my name is Jane” 且 sentence2 &#x3D; “Hello Jane” ，我们可以往sentence2中 “Hello”和”Jane”之间插入”my name is”得到sentence1。<br>给你两个句子sentence1和sentence2，如果sentence1和sentence2是相似的，请你返回true，否则返回false。<br><a href="https://leetcode.cn/problems/sentence-similarity-iii/">https://leetcode.cn/problems/sentence-similarity-iii/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string_view&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp;str,<span class="type">char</span> target)</span></span>&#123;</span><br><span class="line">        vector&lt;string_view&gt; res;</span><br><span class="line">        <span class="function">string_view <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; s.<span class="built_in">size</span>() &amp;&amp; s[pos] == target)&#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> start = pos;</span><br><span class="line">             <span class="keyword">while</span> (pos &lt; s.<span class="built_in">size</span>() &amp;&amp; s[pos] != target) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos &gt; start)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(start,pos - start));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">areSentencesSimilar</span><span class="params">(string sentence1, string sentence2)</span> </span>&#123;</span><br><span class="line">        vector&lt;string_view&gt; s1 = <span class="built_in">split</span>(sentence1,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        vector&lt;string_view&gt; s2 = <span class="built_in">split</span>(sentence2,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;s1[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;s2[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s1.<span class="built_in">size</span>() &amp;&amp; i &lt; s2.<span class="built_in">size</span>() &amp;&amp; s1[i] == s2[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; s1.<span class="built_in">size</span>() - i &amp;&amp; j &lt; s2.<span class="built_in">size</span>() - i &amp;&amp; s1[s1.<span class="built_in">size</span>() - j - <span class="number">1</span>] == s2[s2.<span class="built_in">size</span>() - j - <span class="number">1</span>])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j;</span><br><span class="line">        <span class="keyword">return</span> i + j == <span class="built_in">min</span>(s1.<span class="built_in">size</span>(),s2.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Leetcode-2512-奖励最顶尖的-K-名学生"><a href="#Leetcode-2512-奖励最顶尖的-K-名学生" class="headerlink" title="Leetcode.2512 奖励最顶尖的 K 名学生"></a>Leetcode.2512 奖励最顶尖的 K 名学生</h4><p>出自leetcode第94场双周赛<br>给你两个字符串数组positive_feedback和negative_feedback，分别包含表示正面的和负面的词汇。不会有单词同时是正面的和负面的。<br>一开始，每位学生分数为0.每个正面的单词会给学生的分数加3分，每个负面的词会给学生的分数减1分。<br>给你n个学生的评语，用一个下标从0开始的字符串数组report和一个下标从0开始的整数数组student_id表示，其中student_id[i]表示这名学生的ID，这名学生的评语是report[i]。每名学生的ID互不相同。<br>给你一个整数k，请你返回按照得分从高到低最顶尖的k名学生。如果有多名学生分数相同，ID越小排名越前。<br><a href="https://leetcode.cn/problems/reward-top-k-students/">https://leetcode.cn/problems/reward-top-k-students/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string &amp;str,<span class="type">char</span> target)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="function">string <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; s.<span class="built_in">size</span>() &amp;&amp; s[pos] == target)&#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> start = pos;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; s.<span class="built_in">size</span>() &amp;&amp; s[pos] != target)&#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos &gt; start)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(start,pos - start));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topStudents</span><span class="params">(vector&lt;string&gt;&amp; positive_feedback, vector&lt;string&gt;&amp; negative_feedback, vector&lt;string&gt;&amp; report, vector&lt;<span class="type">int</span>&gt;&amp; student_id, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; cnt1;</span><br><span class="line">        unordered_set&lt;string&gt; cnt2;</span><br><span class="line">        <span class="type">int</span> n = report.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; positive_feedback.<span class="built_in">size</span>();i++)cnt1.<span class="built_in">insert</span>(positive_feedback[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; negative_feedback.<span class="built_in">size</span>();i++)cnt2.<span class="built_in">insert</span>(negative_feedback[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            vector&lt;string&gt; s = <span class="built_in">split</span>(report[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt1.<span class="built_in">count</span>(s[j]))hash[student_id[i]] += <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt2.<span class="built_in">count</span>(s[j]))hash[student_id[i]] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(student_id.<span class="built_in">begin</span>(),student_id.<span class="built_in">end</span>(),[&amp;](<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[a] == hash[b])<span class="keyword">return</span> a &lt; b;</span><br><span class="line">            <span class="keyword">return</span> hash[a] &gt; hash[b];</span><br><span class="line">        &#125;);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++)ans.<span class="built_in">push_back</span>(student_id[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Go语言自带切片函数，用起来要方便很多。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topStudents</span><span class="params">(positive_feedback []<span class="type">string</span>, negative_feedback []<span class="type">string</span>, report []<span class="type">string</span>, student_id []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    score := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,w := <span class="keyword">range</span> positive_feedback&#123;</span><br><span class="line">        score[w] = <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,w := <span class="keyword">range</span> negative_feedback&#123;</span><br><span class="line">        score[w] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">type</span> pair <span class="keyword">struct</span>&#123;score,id <span class="type">int</span>&#125;</span><br><span class="line">    a := <span class="built_in">make</span>([]pair,<span class="built_in">len</span>(report))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i,r := <span class="keyword">range</span> report&#123;</span><br><span class="line">        s := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, w := <span class="keyword">range</span> strings.Split(r, <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">			s += score[w]</span><br><span class="line">		&#125;</span><br><span class="line">        a[i] = pair&#123;s,student_id[i]&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Slice(a, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		a, b := a[i], a[j]</span><br><span class="line">		<span class="keyword">return</span> a.score &gt; b.score || a.score == b.score &amp;&amp; a.id &lt; b.id</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">	<span class="keyword">for</span> i, p := <span class="keyword">range</span> a[:k] &#123;</span><br><span class="line">		ans[i] = p.id</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>push和emplace的区别</title>
    <url>/2023/07/26/push%E5%92%8Cemplace%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>emplace是C++11标准中新增的，与push的效果相同。<br>但在底层实现机制上有所不同：  </p>
<ol>
<li>push会先创建元素，然后将元素拷贝或移动到容器当中，若是拷贝还需要在结束后销毁之前创建的元素</li>
<li>emplace直接在容器尾部创建元素，省去了拷贝或者移动元素的过程。</li>
</ol>
<p>push在底层调用的时候首先调用拷贝函数，然后调用移动构造函数，如无移动构造函数则调用拷贝构造函数。<br>emplace直接传入构造对象需要的元素，然后调用其构造函数。  </p>
<p>相比之下emplace更节省内存，更节省时间。</p>
<p>但其实C++11后，push_back在条件允许的情况下会直接调用emplace。</p>
<p>emplace_back(type) 对应 push_back(type)<br>emplace(i, type) 对应 insert(type, i)<br>emplace_front(type) 对应 push_front()</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>sort函数源码浅析</title>
    <url>/2023/07/28/sort%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>首先肯定是用法,由于在排序过程中涉及到元素交换等操作，所以sort函数仅支持可随机访问的容器，如数组， string、vector、deque等。函数原型如下</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="built_in">typename</span> <span class="variable">_RandomAccessIterator</span>&gt; void <span class="built_in">sort</span>(<span class="variable">_RandomAccessIterator</span> <span class="variable">__first</span>, <span class="variable">_RandomAccessIterator</span> <span class="variable">__last</span>)</span><br><span class="line">template&lt;<span class="built_in">typename</span> <span class="variable">_RandomAccessIterator</span>, <span class="built_in">typename</span> <span class="variable">_Compare</span>&gt; void <span class="built_in">sort</span>(<span class="variable">_RandomAccessIterator</span> <span class="variable">__first</span>, <span class="variable">_RandomAccessIterator</span> <span class="variable">__last</span>, <span class="variable">_Compare</span> <span class="variable">__comp</span>)</span><br></pre></td></tr></table></figure>
<p>不传入第三个参数的话，默认是升序排列，直接传入两个迭代器即可。<br>降序需要传入比较函数。</p>
<span id="more"></span>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">sort(<span class="name">arr</span>.begin(), arr.end(), greater&lt;type&gt;())</span><br></pre></td></tr></table></figure>
<p>传入函数、仿函数、lambda都可实现，若函数返回true，则表示a与b应该交换顺序；若返回false, 则a与b保持原有顺序。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">bool <span class="built_in">cmp</span>(T a, T b);</span><br><span class="line"><span class="built_in">sort</span>(arr.begin(), arr<span class="selector-class">.end</span>(), cmp);</span><br><span class="line"><span class="built_in">sort</span>(arr.begin(), arr<span class="selector-class">.end</span>(), <span class="selector-attr">[&amp;]</span>(T a, T b)&#123;</span><br><span class="line">    return <span class="selector-tag">a</span> &lt; <span class="selector-tag">b</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结构体排序时，需事先自定义比较函数或重载比较运算符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">id</span>, x, y;</span><br><span class="line">    <span class="built_in">bool</span> operator &lt; (Student &amp;a) const &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">id</span> &gt; a.<span class="built_in">id</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">sort(s, s + <span class="number">10</span>);</span><br><span class="line">struct Student &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">id</span>, x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">bool</span> cmp(Student a, Student b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">id</span> &gt; b.<span class="built_in">id</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(s, s + <span class="number">10</span>, cmp);</span><br></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>sort是三种排序的组合使用，快排，插排，堆排，根据数据量自动调整，当数据量较大时采用快排分段递归，分段后数据量小于某个阈值时，会改用插入排序，如果递归层数过深有出现最坏情况的倾向还会改用堆排。<br>首先sort会进行一些合法性检查，之后调用_sort方法。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="built_in">typename</span> <span class="variable">_RandomAccessIterator</span>, <span class="built_in">typename</span> <span class="variable">_Compare</span>&gt;</span><br><span class="line">  <span class="variable">_GLIBCXX20_CONSTEXPR</span></span><br><span class="line">  inline void</span><br><span class="line">  <span class="built_in">sort</span>(<span class="variable">_RandomAccessIterator</span> <span class="variable">__first</span>, <span class="variable">_RandomAccessIterator</span> <span class="variable">__last</span>,</span><br><span class="line"><span class="variable">_Compare</span> <span class="variable">__comp</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// concept requirements</span></span><br><span class="line">    <span class="variable">__glibcxx_function_requires</span>(<span class="variable">_Mutable_RandomAccessIteratorConcept</span>&lt;</span><br><span class="line">   <span class="variable">_RandomAccessIterator</span>&gt;)</span><br><span class="line">    <span class="variable">__glibcxx_function_requires</span>(<span class="variable">_BinaryPredicateConcept</span>&lt;<span class="variable">_Compare</span>,</span><br><span class="line">   <span class="built_in">typename</span> iterator_traits&lt;<span class="variable">_RandomAccessIterator</span>&gt;::value_type,</span><br><span class="line">   <span class="built_in">typename</span> iterator_traits&lt;<span class="variable">_RandomAccessIterator</span>&gt;::value_type&gt;)</span><br><span class="line">    <span class="variable">__glibcxx_requires_valid_range</span>(<span class="variable">__first</span>, <span class="variable">__last</span>);</span><br><span class="line">    <span class="variable">__glibcxx_requires_irreflexive_pred</span>(<span class="variable">__first</span>, <span class="variable">__last</span>, <span class="variable">__comp</span>);</span><br><span class="line"></span><br><span class="line">    std::<span class="variable">__sort</span>(<span class="variable">__first</span>, <span class="variable">__last</span>, <span class="variable">__gnu_cxx</span>::<span class="variable">__ops</span>::<span class="variable">__iter_comp_iter</span>(<span class="variable">__comp</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>_sort的函数模板如下，首先两个迭代器，first !&#x3D; last情况下执行，_introsort_loop是内省排序的实现，_final_insertion_sort是插入排序。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"> template&lt;<span class="built_in">typename</span> <span class="variable">_RandomAccessIterator</span>, <span class="built_in">typename</span> <span class="variable">_Compare</span>&gt;</span><br><span class="line">   <span class="variable">_GLIBCXX20_CONSTEXPR</span></span><br><span class="line">   inline void</span><br><span class="line">   <span class="variable">__sort</span>(<span class="variable">_RandomAccessIterator</span> <span class="variable">__first</span>, <span class="variable">_RandomAccessIterator</span> <span class="variable">__last</span>,</span><br><span class="line">   <span class="variable">_Compare</span> <span class="variable">__comp</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="variable">__first</span> != <span class="variable">__last</span>)</span><br><span class="line">&#123;</span><br><span class="line">  std::<span class="variable">__introsort_loop</span>(<span class="variable">__first</span>, <span class="variable">__last</span>,</span><br><span class="line">			std::<span class="variable">__lg</span>(<span class="variable">__last</span> - <span class="variable">__first</span>) * <span class="number">2</span>,</span><br><span class="line">			<span class="variable">__comp</span>);</span><br><span class="line">  std::<span class="variable">__final_insertion_sort</span>(<span class="variable">__first</span>, <span class="variable">__last</span>, <span class="variable">__comp</span>);</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中内省排序的算法便是sort的核心，他可以根据递归的深度决定是快排还是堆排来实现，能够保证最坏的时间复杂度也是O(NlogN)，同时在序列几乎有序时也会直接使用插入排序。<br>首先，快排在大多数情况下是效率最佳，快排和堆排的渐进时间复杂度相当，而快排基于的是分而治之的思想，父问题分开的子问题本质上是不重叠的，减少了大量的无效比较。<br>但其实快排的效率很大程度上取决于pivot元素的选取，最好的情况下，pivot每次都能将数据等分成两半，这样递归的深度就是logN，时间复杂度为O(NlogN),但在特殊情况下比如说每次选的pivot都分在数组最端点，这样递归的树变成了完全向一侧倾斜，递归深度N - 1，这种情况下复杂度O(N^2)。<br>当快排进入这种情况时，应切换到堆排序，堆排虽然可能不如快排效率高在任何情况下都是O(NlogN)，当快排递归的开销过大时，使用堆排是比较好的方案。<br>观察如下introsort的函数模板，首先可以看到一个_S_threshold的宏，判断的是范围大小，当范围小于16时则可认定这个序列基本有序，退出使用插排。而再往下是_depth_limit其实就是递归次数的限制。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"> template&lt;<span class="built_in">typename</span> <span class="variable">_RandomAccessIterator</span>, <span class="built_in">typename</span> <span class="variable">_Size</span>, <span class="built_in">typename</span> <span class="variable">_Compare</span>&gt;</span><br><span class="line">   <span class="variable">_GLIBCXX20_CONSTEXPR</span></span><br><span class="line">   void</span><br><span class="line">   <span class="variable">__introsort_loop</span>(<span class="variable">_RandomAccessIterator</span> <span class="variable">__first</span>,</span><br><span class="line">	     <span class="variable">_RandomAccessIterator</span> <span class="variable">__last</span>,</span><br><span class="line">	     <span class="variable">_Size</span> <span class="variable">__depth_limit</span>, <span class="variable">_Compare</span> <span class="variable">__comp</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="variable">__last</span> - <span class="variable">__first</span> &gt; int(<span class="variable">_S_threshold</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">__depth_limit</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      std::<span class="variable">__partial_sort</span>(<span class="variable">__first</span>, <span class="variable">__last</span>, <span class="variable">__last</span>, <span class="variable">__comp</span>);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  --<span class="variable">__depth_limit</span>;</span><br><span class="line">  <span class="variable">_RandomAccessIterator</span> <span class="variable">__cut</span> =</span><br><span class="line">    std::<span class="variable">__unguarded_partition_pivot</span>(<span class="variable">__first</span>, <span class="variable">__last</span>, <span class="variable">__comp</span>);</span><br><span class="line">  std::<span class="variable">__introsort_loop</span>(<span class="variable">__cut</span>, <span class="variable">__last</span>, <span class="variable">__depth_limit</span>, <span class="variable">__comp</span>);</span><br><span class="line">  <span class="variable">__last</span> = <span class="variable">__cut</span>;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  @doctodo</span></span><br><span class="line"><span class="comment">  *  This controls some aspect of the sort routines.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> enum &#123; <span class="variable">_S_threshold</span> = <span class="number">16</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>当快速排序遇到最坏情况时，意味着在递归时会连续多次选中带分割区间的最值元素，从而导致多次无效分割，进而导致递归层数快速增加。在introsort的设计中一旦递归深度超出一个阈值，则认为快速排序掉入陷阱并切换到堆排序算法。快速排序在理想状态下应当递归约logn次。因此，如果递归深度明显大于logn，说明快速排序就掉进陷阱了。<br>回看_sort模板在调用introsort时，传进的参数是std::__lg(__last - __first) * 2，其实就是2 * logn，这是应当终止递归的阈值设置。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">std::<span class="variable">__introsort_loop</span>(<span class="variable">__first</span>, <span class="variable">__last</span>,</span><br><span class="line">				std::<span class="variable">__lg</span>(<span class="variable">__last</span> - <span class="variable">__first</span>) * <span class="number">2</span>,</span><br><span class="line">				<span class="variable">__comp</span>);</span><br></pre></td></tr></table></figure>
<p>同时，通过上文代码可以看到depth_limit每次调用会自减一次，到零的话则调用partial_sort，进入到建堆和堆排的过程中了。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="built_in">typename</span> <span class="variable">_RandomAccessIterator</span>, <span class="built_in">typename</span> <span class="variable">_Compare</span>&gt;</span><br><span class="line">    <span class="variable">_GLIBCXX20_CONSTEXPR</span></span><br><span class="line">    inline void</span><br><span class="line">    <span class="variable">__partial_sort</span>(<span class="variable">_RandomAccessIterator</span> <span class="variable">__first</span>,</span><br><span class="line">		   <span class="variable">_RandomAccessIterator</span> <span class="variable">__middle</span>,</span><br><span class="line">		   <span class="variable">_RandomAccessIterator</span> <span class="variable">__last</span>,</span><br><span class="line">		   <span class="variable">_Compare</span> <span class="variable">__comp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      std::<span class="variable">__heap_select</span>(<span class="variable">__first</span>, <span class="variable">__middle</span>, <span class="variable">__last</span>, <span class="variable">__comp</span>);</span><br><span class="line">      std::<span class="variable">__sort_heap</span>(<span class="variable">__first</span>, <span class="variable">__middle</span>, <span class="variable">__comp</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>unguarded_partition_pivot则是pivot元素的选取，返回一个迭代器。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// This is a helper function...</span></span><br><span class="line">template&lt;<span class="built_in">typename</span> <span class="variable">_RandomAccessIterator</span>, <span class="built_in">typename</span> <span class="variable">_Compare</span>&gt;</span><br><span class="line"><span class="variable">_GLIBCXX20_CONSTEXPR</span></span><br><span class="line">inline <span class="variable">_RandomAccessIterator</span></span><br><span class="line"><span class="variable">__unguarded_partition_pivot</span>(<span class="variable">_RandomAccessIterator</span> <span class="variable">__first</span>,</span><br><span class="line">            <span class="variable">_RandomAccessIterator</span> <span class="variable">__last</span>, <span class="variable">_Compare</span> <span class="variable">__comp</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">_RandomAccessIterator</span> <span class="variable">__mid</span> = <span class="variable">__first</span> + (<span class="variable">__last</span> - <span class="variable">__first</span>) / <span class="number">2</span>;</span><br><span class="line">    std::<span class="variable">__move_median_to_first</span>(<span class="variable">__first</span>, <span class="variable">__first</span> + <span class="number">1</span>, <span class="variable">__mid</span>, <span class="variable">__last</span> - <span class="number">1</span>,</span><br><span class="line">                <span class="variable">__comp</span>);</span><br><span class="line">    return std::<span class="variable">__unguarded_partition</span>(<span class="variable">__first</span> + <span class="number">1</span>, <span class="variable">__last</span>, <span class="variable">__first</span>, <span class="variable">__comp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了高效，首先进入右递归，然后last &#x3D; pivot进行左递归，当while的判断条件失效时，会避免更多的递归。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">_RandomAccessIterator</span> <span class="variable">__cut</span> =</span><br><span class="line">	    std::<span class="variable">__unguarded_partition_pivot</span>(<span class="variable">__first</span>, <span class="variable">__last</span>, <span class="variable">__comp</span>);</span><br><span class="line">	  std::<span class="variable">__introsort_loop</span>(<span class="variable">__cut</span>, <span class="variable">__last</span>, <span class="variable">__depth_limit</span>, <span class="variable">__comp</span>);</span><br><span class="line">	  <span class="variable">__last</span> = <span class="variable">__cut</span>;</span><br></pre></td></tr></table></figure>
<p>再细看unguarded_partition_pivot的实现，可以学习一下STL选取分割位置的方法。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// This is a helper function...</span></span><br><span class="line">template&lt;<span class="built_in">typename</span> <span class="variable">_RandomAccessIterator</span>, <span class="built_in">typename</span> <span class="variable">_Compare</span>&gt;</span><br><span class="line"><span class="variable">_GLIBCXX20_CONSTEXPR</span></span><br><span class="line">inline <span class="variable">_RandomAccessIterator</span></span><br><span class="line"><span class="variable">__unguarded_partition_pivot</span>(<span class="variable">_RandomAccessIterator</span> <span class="variable">__first</span>,</span><br><span class="line">            <span class="variable">_RandomAccessIterator</span> <span class="variable">__last</span>, <span class="variable">_Compare</span> <span class="variable">__comp</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">_RandomAccessIterator</span> <span class="variable">__mid</span> = <span class="variable">__first</span> + (<span class="variable">__last</span> - <span class="variable">__first</span>) / <span class="number">2</span>;</span><br><span class="line">    std::<span class="variable">__move_median_to_first</span>(<span class="variable">__first</span>, <span class="variable">__first</span> + <span class="number">1</span>, <span class="variable">__mid</span>, <span class="variable">__last</span> - <span class="number">1</span>,</span><br><span class="line">                <span class="variable">__comp</span>);</span><br><span class="line">    return std::<span class="variable">__unguarded_partition</span>(<span class="variable">__first</span> + <span class="number">1</span>, <span class="variable">__last</span>, <span class="variable">__first</span>, <span class="variable">__comp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__move_median_to_first是找出__a、__b、__c的中值，并将这个中值放在__result位置处。因此，根据传入参数，就是找出__first+1、__mid、__last-1三个位置的中值，并将中值和__first位置的值进行交换。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Swaps the median value of *__a, *__b and *__c under __comp to *__result</span></span><br><span class="line"> template&lt;<span class="built_in">typename</span> <span class="variable">_Iterator</span>, <span class="built_in">typename</span> <span class="variable">_Compare</span>&gt;</span><br><span class="line">   <span class="variable">_GLIBCXX20_CONSTEXPR</span></span><br><span class="line">   void</span><br><span class="line">   <span class="variable">__move_median_to_first</span>(<span class="variable">_Iterator</span> <span class="variable">__result</span>,<span class="variable">_Iterator</span> <span class="variable">__a</span>, <span class="variable">_Iterator</span> <span class="variable">__b</span>,</span><br><span class="line">		   <span class="variable">_Iterator</span> <span class="variable">__c</span>, <span class="variable">_Compare</span> <span class="variable">__comp</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="variable">__comp</span>(<span class="variable">__a</span>, <span class="variable">__b</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">__comp</span>(<span class="variable">__b</span>, <span class="variable">__c</span>))</span><br><span class="line">    std::iter_swap(<span class="variable">__result</span>, <span class="variable">__b</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">__comp</span>(<span class="variable">__a</span>, <span class="variable">__c</span>))</span><br><span class="line">    std::iter_swap(<span class="variable">__result</span>, <span class="variable">__c</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    std::iter_swap(<span class="variable">__result</span>, <span class="variable">__a</span>);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">__comp</span>(<span class="variable">__a</span>, <span class="variable">__c</span>))</span><br><span class="line">std::iter_swap(<span class="variable">__result</span>, <span class="variable">__a</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">__comp</span>(<span class="variable">__b</span>, <span class="variable">__c</span>))</span><br><span class="line">std::iter_swap(<span class="variable">__result</span>, <span class="variable">__c</span>);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">std::iter_swap(<span class="variable">__result</span>, <span class="variable">__b</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>找到pivot之后__unguarded_partition(__first + 1, __last, __first, __comp)进行分割。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"> template&lt;<span class="built_in">typename</span> <span class="variable">_RandomAccessIterator</span>, <span class="built_in">typename</span> <span class="variable">_Compare</span>&gt;</span><br><span class="line">   <span class="variable">_GLIBCXX20_CONSTEXPR</span></span><br><span class="line">   <span class="variable">_RandomAccessIterator</span></span><br><span class="line">   <span class="variable">__unguarded_partition</span>(<span class="variable">_RandomAccessIterator</span> <span class="variable">__first</span>,</span><br><span class="line">		  <span class="variable">_RandomAccessIterator</span> <span class="variable">__last</span>,</span><br><span class="line">		  <span class="variable">_RandomAccessIterator</span> <span class="variable">__pivot</span>, <span class="variable">_Compare</span> <span class="variable">__comp</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="variable">__comp</span>(<span class="variable">__first</span>, <span class="variable">__pivot</span>))</span><br><span class="line">    ++<span class="variable">__first</span>;</span><br><span class="line">  --<span class="variable">__last</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="variable">__comp</span>(<span class="variable">__pivot</span>, <span class="variable">__last</span>))</span><br><span class="line">    --<span class="variable">__last</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable">__first</span> &lt; <span class="variable">__last</span>))</span><br><span class="line">    return <span class="variable">__first</span>;</span><br><span class="line">  std::iter_swap(<span class="variable">__first</span>, <span class="variable">__last</span>);</span><br><span class="line">  ++<span class="variable">__first</span>;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上述函数调用结束后，在序列大小小于一定数字时，就跳出introsort的过程了，进入插入排序的过程。插排在已经部分有序的序列中非常快，接近O(n)的复杂度，而堆排或快排如果按照各自的算法，没有利用已经部分有序的前提，所以就不如插排。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"> template&lt;<span class="built_in">typename</span> <span class="variable">_RandomAccessIterator</span>, <span class="built_in">typename</span> <span class="variable">_Compare</span>&gt;</span><br><span class="line">   <span class="variable">_GLIBCXX20_CONSTEXPR</span></span><br><span class="line">   void</span><br><span class="line">   <span class="variable">__final_insertion_sort</span>(<span class="variable">_RandomAccessIterator</span> <span class="variable">__first</span>,</span><br><span class="line">		   <span class="variable">_RandomAccessIterator</span> <span class="variable">__last</span>, <span class="variable">_Compare</span> <span class="variable">__comp</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="variable">__last</span> - <span class="variable">__first</span> &gt; int(<span class="variable">_S_threshold</span>))</span><br><span class="line">&#123;</span><br><span class="line">  std::<span class="variable">__insertion_sort</span>(<span class="variable">__first</span>, <span class="variable">__first</span> + int(<span class="variable">_S_threshold</span>), <span class="variable">__comp</span>);</span><br><span class="line">  std::<span class="variable">__unguarded_insertion_sort</span>(<span class="variable">__first</span> + int(<span class="variable">_S_threshold</span>), <span class="variable">__last</span>,</span><br><span class="line">				  <span class="variable">__comp</span>);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">std::<span class="variable">__insertion_sort</span>(<span class="variable">__first</span>, <span class="variable">__last</span>, <span class="variable">__comp</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>函数模板内有一个 if 分支。当区间长度较小时，直接调用__insertion_sort；当区间长度较大时，对前__stl_threshold 个元素调用 __insertion_sort，而对前 __stl_threshold 个元素之后的元素调用__unguarded_insertion_sort。<br>借由此种实现方式，其效率比标准的插入排序效率要高。基于函数调用的条件，__unguarded_insertion_sort无需检测数据越界，在一定程度上对性能有所优化。</p>
<h4 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h4><p>《STL源码剖析》<a href="https://book.douban.com/subject/1110934/">https://book.douban.com/subject/1110934/</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>C++</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>linux三剑客</title>
    <url>/2023/07/30/linux%E4%B8%89%E5%89%91%E5%AE%A2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>怎么不析构就置vector的capacity为0</title>
    <url>/2023/08/03/%E6%80%8E%E4%B9%88%E4%B8%8D%E6%9E%90%E6%9E%84%E5%B0%B1%E7%BD%AEvector%E7%9A%84capacity%E4%B8%BA0/</url>
    <content><![CDATA[<p>vector的内存占用空间不会随着clear()和erase()方法的调用而减少，元素虽然去除但是内存空间只有在vector析构的时候才能被系统回收。像resize()方法如果缩小大小，虽然后续的元素无法被访问了，但内存空间也没有被释放。<br>其实如果需要空间动态缩小，可以用deque。<br>那么在不调用析构函数的情况下怎么释放vector的内存呢。  </p>
<p>swap方法可以交换两容器的内容。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">arr1.swap(arr2)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这可以用来收缩内存空间，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br></pre></td></tr></table></figure>
<p>首先vector(v)利用拷贝构造函数创建了一个匿名对象，拥有全部的数据但没有空闲的空间。之后通过调用swap交换了v与匿名类的内容。<br>该语句执行完毕后匿名对象被析构，空间自动释放，达到了我们想要的效果。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针底层浅析</title>
    <url>/2023/08/01/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%BA%95%E5%B1%82%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CF1555D Say No to Palindromes</title>
    <url>/2023/08/27/CF1555D/</url>
    <content><![CDATA[<p>CF1555D<br><a href="https://codeforces.com/problemset/problem/1555/D">https://codeforces.com/problemset/problem/1555/D</a><br>阿里巴巴控股集团笔试第三题改了下修改区间在线查询，原题是个比较简单的贪心，想清楚只有六种情况就可以了。</p>
<p>Let’s call the string beautiful if it does not contain a substring of length at least 2, which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.</p>
<span id="more"></span>  
<p>Let’s define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet (in lowercase).</p>
<p>You are given a string s of length n, each character of the string is one of the first 3 letters of the Latin alphabet (in lowercase).</p>
<p>You have to answer m queries — calculate the cost of the substring of the string s from li-th to ri-th position, inclusive.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line contains two integers n and m (1≤n,m≤2⋅105) — the length of the string s and the number of queries.</p>
<p>The second line contains the string s, it consists of n characters, each character one of the first 3 Latin letters.</p>
<p>The following m lines contain two integers li and ri (1≤li≤ri≤n) — parameters of the i-th query.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each query, print a single integer — the cost of the substring of the string s from li-th to ri-th position, inclusive.</p>
<p>条件是不能出现长度大于等于2的回文串，且只有abc三个字母。<br>beautiful串其实是固定的，aa bb cc这种组合肯定不能出现，如果两位为ab那第三位只能为c，后续的字母都递推为唯一的结果，字符串开头两位ab ba ac ca bc cb六种情况，符合条件的只有六个串而已，直接枚举。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>e5 + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">7</span>][N];</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">solve</span>(<span class="keyword">string</span> s, <span class="keyword">string</span> t, <span class="keyword">int</span> num, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		pre[num][i + <span class="number">1</span>] += pre[num][i];</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; s[i] != t[<span class="number">0</span>]) &#123;</span><br><span class="line">			pre[num][i + <span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span> &amp;&amp; s[i] != t[<span class="number">1</span>]) &#123;</span><br><span class="line">			pre[num][i + <span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span> &amp;&amp; s[i] != t[<span class="number">2</span>]) &#123;</span><br><span class="line">			pre[num][i + <span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">string</span> s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">solve</span>(s, <span class="string">&quot;abc&quot;</span>, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">solve</span>(s, <span class="string">&quot;acb&quot;</span>, <span class="number">2</span>, n);</span><br><span class="line">	<span class="keyword">solve</span>(s, <span class="string">&quot;bac&quot;</span>, <span class="number">3</span>, n);</span><br><span class="line">	<span class="keyword">solve</span>(s, <span class="string">&quot;bca&quot;</span>, <span class="number">4</span>, n);</span><br><span class="line">	<span class="keyword">solve</span>(s, <span class="string">&quot;cab&quot;</span>, <span class="number">5</span>, n);</span><br><span class="line">	<span class="keyword">solve</span>(s, <span class="string">&quot;cba&quot;</span>, <span class="number">6</span>, n);</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">1</span>e9 + <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">			ans = min(ans, pre[j][r] - pre[j][l - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
</search>
